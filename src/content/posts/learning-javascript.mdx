---
title: 'Conceptos b√°sicos de javascript para principiantes y no tan principiantes'
category: "explain"
createdAt: 2022-04-21
updatedAt: 2023-10-04
---

## Introducci√≥n

Personalmente creo que es de vital importancia entender algunos conceptos clave de javascript, como por ejemplo, el scope, la mutaci√≥n, las funciones y los objetos, etc.
ya que estos nos proveen de diversas caracter√≠sticas y funciones que nos permiten trabajar con el lenguaje de forma mas sencilla y eficiente, por eso me he dado a la tarea de agrupar algunas de estas caracter√≠sticas de javascript que lo hacen el lenguaje popular que es hoy, y tratare de simplificar lo mas posible el tema para que pueda ser entendido por los dem√°s üòÄ.

## Caracter√≠sticas del lenguaje

Como cualquier otro lenguaje de programaci√≥n, javascript esta dotado de diversas caracter√≠sticas y peculiaridades que son las que definen con que facilidad podremos trabajar al momento de crear nuestras aplicaciones, siendo uno de los lenguajes mas populares actualmente veamos que nos puede ofrecer.

### Scope üü¶

El **scope** en palabras sencillas lo podemos entender como un _ambiente_ o _entorno_ en el que se encuentra una variable, una funci√≥n, una clase, etc.

Dentro de este entorno cualquier declaraci√≥n de variable o funci√≥n que se haga sera accesible solo dentro del mismo.

```js
const name = 'John'
const age = 23
const country = 'US'
// Todas las declaraciones anteriores se encuentran dentro del
// scope "global" por lo que podemos acceder a ellas desde cualquier lugar.

function getAge() {
    return age // 23
  }

if (age > 18) {
  const isOlder = true
  // La constante "isOlder" solo esta disponible dentro del scope "if"
  // por lo que no podemos acceder a ella desde fuera del scope, por ejemplo.
}

console.log(isOlder) // undefined
  ```

## Mutaci√≥n ‚ò¢Ô∏è

La **mutaci√≥n** es otro concepto que nos ayuda a entender el ciclo de vida de las variables en javascript, es decir, cuando una variable es mutada, esta puede cambiar de valor y esto puede causar un comportamiento inesperado si no sabemos en que punto de nuestra aplicaci√≥n hemos mutado su valor, por ejemplo:

```js
const fruits = ['apple', 'banana', 'orange']
const orange = fruits.pop() // ["orange"]
console.log(fruits) // ["apple", "banana"]
  ```

Como podemos ver, al utilizar el m√©todo `.pop(){:js}` estamos obteniendo el ultimo valor de el arreglo `fruits{:js}`, pero a su vez este mismo ha perdido su ultimo valor, por lo que al momento de imprimir el valor de `fruits{:js}`, el elemento `"orange"{:.str}` ya no esta disponible.

En javascript tenemos m√©todos que mutan el valor de una variable, en este caso tomaremos de ejemplo los arreglos, como por ejemplo:

- `.push(){:js}`: Agrega un elemento al final del arreglo
- `.pop(){:js}`: Elimina el ultimo elemento del arreglo
- `.shift(){:js}`: Elimina el primer elemento del arreglo
- `.unshift(){:js}`: Agrega un elemento al inicio del arreglo

M√©todos que mutan el valor de un string...

- `.concat(){:js}`: Concatena un string con otro string
- `.slice(){:js}`: Extrae una porci√≥n del string
- `.split(){:js}`: Divide un string en un arreglo
- `.substr(){:js}`: Extrae una porci√≥n del string
- `.substring(){:js}`: Extrae una porci√≥n del string
- `.toLowerCase(){:js}`: Convierte el string a min√∫sculas
- `.toUpperCase(){:js}`: Convierte el string a may√∫sculas

M√©todos que mutan el valor de un numero...

- `.toString(){:js}`: Convierte el numero en un string
- `.toFixed(){:js}`: Convierte el numero en un string con una cantidad de decimales
- `.toExponential(){:js}`: Convierte el numero en un string con una cantidad de decimales
- `.toPrecision(){:js}`: Convierte el numero en un string con una cantidad de decimales

Y m√©todos que mutan el valor de un objeto.

- `.assign(){:js}`: Asigna un valor a una propiedad de un objeto
- `.deleteProperty(){:js}`: Elimina una propiedad de un objeto
- `.defineProperty(){:js}`: Define una propiedad de un objeto
- `.freeze(){:js}`: Congela un objeto
- `.seal(){:js}`: Se cierra un objeto
- `.preventExtensions(){:js}`: Evita que un objeto sea extensible
- `.isFrozen(){:js}`: Verifica si un objeto esta congelado
- `.isSealed(){:js}`: Verifica si un objeto esta cerrado
- `.isExtensible(){:js}`: Verifica si un objeto es extensible

## Funciones üêõ‚û°ü¶ã

Una funci√≥n la podemos entender como una serie de instrucciones agrupadas que puede ser invocada desde casi cualquier lugar, con la finalidad de separar en m√≥dulos el c√≥digo y poder reutilizarlo en diferentes partes de nuestra aplicaci√≥n, la cual cuenta con una serie de caracter√≠sticas que nos permiten realizar estas tareas.

Si tenemos un bloque de c√≥digo que realiza alguna operaci√≥n, podemos crear una funci√≥n que lo haga, y luego invocarla desde cualquier lugar sin tener que repetir el mismo c√≥digo, por ejemplo:

```javascript title = "funciones.js"
function sumNumbers (num1, num2) {
  return num1 + num2
}
sumNumbers(1, 2) // Retorna 3
  ```

Aqu√≠ tenemos el ejemplo mas com√∫n de como crear una funci√≥n en javascript, y como invocarla, pero debemos tener ciertos factores en cuenta a la hora de crear una funci√≥n, por ejemplo:

### `Nombre de la funci√≥n`

El nombre debe ser claro, corto y consistente usando la nomenclatura **_camelCase_** en ingles, ademas de representar el prop√≥sito de la funci√≥n sin agregados extras.
Com√∫nmente de utilizan ciertos prefijos como `get` y `set` para indicar que la funci√≥n es un _getter_ o _setter_ y sufijos como _Handler_ para indicar que la funci√≥n es un gestor de eventos.

Por ejemplo:

- `sumNumbers{:.fn}`: Suma dos n√∫meros
- `getAge{:.fn}`: Retorna la edad de una persona
- `setAge{:.fn}`: Cambia la edad de una persona
- `onClickHandler{:.fn}`: Maneja el evento click

### `Par√°metros`

Cuando creamos una funci√≥n, podemos definir una serie de par√°metros que modificaran el comportamiento de la funci√≥n en base al valor de estos.

Al igual que con las funciones, los par√°metros deben ser consistes para identificar el valor que representa y su uso en el c√≥digo, pero a diferencia de el nombre en las funciones, estos solo deben especificar el uso en su nombre sin agregados innecesarios.

## Callbacks ‚óÄÔ∏è

Los **callbacks** son otras de esas funcionalidades que vale la pena conocer, si bien su uso se ha reducido significativamente en los √∫ltimos a√±os, este sigue presente en en lenguaje aunque de forma m√°s sutil en los m√©todos de un arreglo o en `polyfills{:.const}`.

De una manera muy sencilla, un callback no es m√°s que una funci√≥n que se ejecutar√° dentro de otra funci√≥n una vez que la primera se termine de ejecutar, es decir, a una funci√≥n le estaremos pasando otra una vez que la primera termin√©.

```js
const numbers = [1, 2, 3, 4]

const doubles = numbers.map(number => number * 2)
  // el callback es la funci√≥n que recibe el map()
  // en este caso es una funci√≥n de tipo flecha
  ```

Por ejemplo, la funci√≥n `map(){:js}` es un m√©todo del `Array.prototype{:js}`, es decir, un m√©todo disponible en todos los arreglos, este recibe un una funci√≥n que le indique que hacer una vez que la funci√≥n `.map(){:js}` ha terminado de ejecutarse y est√° recibe un argumento que luego usa para hacer las transformaciones correspondientes.

## Promesas ü§ù

Las Promesas las podemos considerar una evoluci√≥n natural de los Callbacks, ya que un uso com√∫n de los Callbacks se encuentran enfocados a operaciones _as√≠ncronas_ ya que su sintaxis es m√°s comprensible que la de los callbacks, por ejemplo:

```js
const res = fetch('https://url/api')
  .then(res => res.json())
  .catch(res => console.error(res))
  .finally(() => console.log('Promise completely'))
  ```

Una promesa cuenta con 3 partes, el `.then(){:js}`, `.catch(){:js}`, y `.finally(){:js}` que son m√©todos que caracterizan a una promesa aunque por el momento solo hablaremos de then y catch que son los m√°s comunes.

#### `.then(){:js}`

Posiblemente este es el m√©todo principal por el cual se distinguen la promesas ya que es el que se encargar√° de devolver o transformar un valor dependiendo de la implementaci√≥n.

Mas f√°cilmente podemos entender a `then(){:js}` como el m√©todo que hace algo una vez que la promesa ha terminado, y dentro de then() escribimos un callback que es el que se encargar√° de recibir la respuesta que la promesa haya devuelto.

#### `.catch(){:js}`

Catch podemos considerarlo como un m√©todo auxiliar, es decir, una contra-medida en caso de que la promesa no se resuelva correctamente y est√° retorne un error, como por ejemplo, Si una petici√≥n a una API devuelve un c√≥digo de estado en el rango de 400 a 500, esto se considerar√≠a como una promesa no resuelta, por lo que el m√©todo _.then()_ quedar√≠a anulado y se saltar√≠a directamente al m√©todo `catch(){:js}` y este recibir√≠a un callback para manejar el error, por ejemplo:

```js
fetch('https://invalid.url')
  .then(/*Esto ya no se ejecutara*/)
  .catch(error => console.log(error))
  // muestra el error en consola
  ```

## Async/Await üïí

Y finalmente **async /await** es una forma de escribir una funci√≥n que sea as√≠ncrona con una sintaxis mas clara y limpia que las promesas en donde ahora contaremos con 2 palabras reservadas para realizar esto, que como pueden imaginar, son `async{:js}` y `await{:js}`.

**Async** es la manera con la cual definimos que la que la funci√≥n devolver√° una promesa, si, una promesa. Aunque la funci√≥n utiliza las palabra `async{:ts}`, esta es solo un indicador del tipo de funci√≥n, en este caso, una funci√≥n as√≠ncrona, pero el tipo de dato que retorna es una promesa (_Promise_).

**Await** es la instrucci√≥n que indica que la funci√≥n esperara a que la promesa se resuelva, antes de continuar con las siguientes instrucciones.

```js
async function getData () {
  const res = await fetch('https://url/api')
  const data = await res.json()
  return data
}
```

Tanto `fetch(){:js}` como su m√©todo `.json(){:js}` son funciones as√≠ncronas, es decir, que toman un determinado tiempo antes de devolver un valor, por lo que definimos la palabra **await** para indicarle que nos esperaremos a que la promesa nos devuelva el valor que esperamos para poder continuar con las operaciones, en este caso como ambas funciones son as√≠ncronas, definimos 2 veces las palabras await para tener una continuidad correcta en el procesamiento de los datos.

## Notas finales

Quisiera hacer menci√≥n que algunas de las cosas que mencion√© como algunas reglas de escritura de c√≥digo, son opiniones personales y no deber√≠an tomarse como norma absoluta para el lenguaje, pero si debo mencionar que muchas de estas reglas se usan actualmente ya que permite una mejor colaboraci√≥n en las aplicaciones que realices.
