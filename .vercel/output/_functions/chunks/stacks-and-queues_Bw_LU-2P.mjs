const id = "stacks-and-queues.mdx";
						const collection = "blog";
						const slug = "stacks-and-queues";
						const body = "\r\n## Introducción\r\n\r\nLas pilas y colas son estructuras de datos que se utilizan en la programación para almacenar datos. Las pilas y colas son estructuras de datos lineales, lo que significa que solo pueden almacenar datos en una dirección. Las pilas y colas son estructuras de datos de tipo LIFO (último en entrar, primero en salir) y FIFO (primero en entrar, primero en salir), respectivamente.\r\n\r\n## Pilas\r\n\r\n![Stack introduction](/media/stacks-and-queues-1.png)\r\n\r\nLas pilas son esa estructura de datos que usariamos en la vida real para apilar informacion y poder acceder a la ultima informacion que se agrego.\r\nSupongamos que tenemos una pila de libros, y queremos acceder al libro que esta en la parte superior de la pila, para eso lo que haremos es sacar todos los libros que estan encima de el, y asi podremos acceder al libro que queremos.\r\n\r\n![Stack example](/media/stacks-and-queues-2.png)\r\n\r\nSi pensamos en la pila como una lista de nodos, asumiento que el ultimo nodo que se agrego se enlaza con el penultimo nodo, y asi sucesivamente, entonces el ultimo nodo que se agrego sera el primero en salir de la pila.\r\n\r\n### Operaciones\r\n\r\n- **Push**: Agregar un elemento a la pila.\r\n- **Pop**: Eliminar un elemento de la pila.\r\n- **Peek**: Obtener el elemento que esta en la parte superior de la pila.\r\n- **isEmpty**: Verificar si la pila esta vacia.\r\n\r\n### Implementacion de pilas en diferentes lenguajes de programación\r\n\r\n<details>\r\n  <summary>Python</summary>\r\n\r\n```python\r\nclass StackNode:\r\n    def __init__(self, value):\r\n        self.value = value\r\n        self.next = None\r\n\r\nclass Stack:\r\n    def __init__(self):\r\n        self.top = None\r\n\r\n    def push(self, value):\r\n        node = StackNode(value)\r\n        node.next = self.top\r\n        self.top = node\r\n\r\n    def pop(self):\r\n        if self.top is None:\r\n            return None\r\n        node = self.top\r\n        self.top = self.top.next\r\n        return node.value\r\n\r\n    def peek(self):\r\n        if self.top is None:\r\n            return None\r\n        return self.top.value\r\n\r\n    def is_empty(self):\r\n        return self.top is None\r\n\r\n    def print(self):\r\n        node = self.top\r\n        while node is not None:\r\n            print(node.value)\r\n            node = node.next\r\n    \r\n    def __str__(self):\r\n        return str(self.top)\r\n\r\nstack = Stack()\r\nstack.push(1)\r\nstack.push(2)\r\nstack.push(3)\r\n\r\nprint(stack.peek()) # 3\r\n```\r\n</details>\r\n\r\n<details>\r\n  <summary>JavaScript</summary>\r\n\r\n```javascript\r\nclass StackNode {\r\n  constructor(value) {\r\n    this.value = value;\r\n    this.next = null;\r\n  }\r\n}\r\n\r\nclass Stack {\r\n  constructor() {\r\n    this.top = null;\r\n  }\r\n\r\n  push(value) {\r\n    const node = new StackNode(value);\r\n    node.next = this.top;\r\n    this.top = node;\r\n  }\r\n\r\n  pop() {\r\n    if (this.top === null) {\r\n      return null;\r\n    }\r\n    const node = this.top;\r\n    this.top = this.top.next;\r\n    return node.value;\r\n  }\r\n\r\n  peek() {\r\n    if (this.top === null) {\r\n      return null;\r\n    }\r\n    return this.top.value;\r\n  }\r\n\r\n  isEmpty() {\r\n    return this.top === null;\r\n  }\r\n\r\n  print() {\r\n    let node = this.top;\r\n    while (node !== null) {\r\n      console.log(node.value);\r\n      node = node.next;\r\n    }\r\n  }\r\n\r\n  toString() {\r\n    return this.top;\r\n  }\r\n}\r\n\r\nconst stack = new Stack();\r\nstack.push(1);\r\nstack.push(2);\r\nstack.push(3);\r\n\r\nconsole.log(stack.peek()); // 3\r\n```\r\n</details>\r\n\r\n<details>\r\n  <summary>Java</summary>\r\n\r\n```java\r\nclass StackNode {\r\n  int value;\r\n  StackNode next;\r\n\r\n  StackNode(int value) {\r\n    this.value = value;\r\n    this.next = null;\r\n  }\r\n}\r\n\r\nclass Stack {\r\n  StackNode top;\r\n\r\n  Stack() {\r\n    this.top = null;\r\n  }\r\n\r\n  void push(int value) {\r\n    StackNode node = new StackNode(value);\r\n    node.next = this.top;\r\n    this.top = node;\r\n  }\r\n\r\n  int pop() {\r\n    if (this.top == null) {\r\n      return -1;\r\n    }\r\n    StackNode node = this.top;\r\n    this.top = this.top.next;\r\n    return node.value;\r\n  }\r\n\r\n  int peek() {\r\n    if (this.top == null) {\r\n      return -1;\r\n    }\r\n    return this.top.value;\r\n  }\r\n\r\n  boolean isEmpty() {\r\n    return this.top == null;\r\n  }\r\n\r\n  void print() {\r\n    StackNode node = this.top;\r\n    while (node != null) {\r\n      System.out.println(node.value);\r\n      node = node.next;\r\n    }\r\n  }\r\n\r\n  @Override\r\n  public String toString() {\r\n    return this.top.toString();\r\n  }\r\n}\r\n\r\npublic class Main {\r\n  public static void main(String[] args) {\r\n    Stack stack = new Stack();\r\n    stack.push(1);\r\n    stack.push(2);\r\n    stack.push(3);\r\n\r\n    System.out.println(stack.peek()); // 3\r\n  }\r\n}\r\n```\r\n</details>\r\n<details>\r\n  <summary>C++</summary>\r\n\r\n```cpp\r\n#include <iostream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nclass StackNode {\r\n  public:\r\n    int value;\r\n    StackNode *next;\r\n\r\n    StackNode(int value) {\r\n      this->value = value;\r\n      this->next = NULL;\r\n    }\r\n};\r\n\r\nclass Stack {\r\n  public:\r\n    StackNode *top;\r\n\r\n    Stack() {\r\n      this->top = NULL;\r\n    }\r\n\r\n    void push(int value) {\r\n      StackNode *node = new StackNode(value);\r\n      node->next = this->top;\r\n      this->top = node;\r\n    }\r\n\r\n    int pop() {\r\n      if (this->top == NULL) {\r\n        return -1;\r\n      }\r\n      StackNode *node = this->top;\r\n      this->top = this->top->next;\r\n      return node->value;\r\n    }\r\n\r\n    int peek() {\r\n      if (this->top == NULL) {\r\n        return -1;\r\n      }\r\n      return this->top->value;\r\n    }\r\n\r\n    bool isEmpty() {\r\n      return this->top == NULL;\r\n    }\r\n\r\n    void print() {\r\n      StackNode *node = this->top;\r\n      while (node != NULL) {\r\n        cout << node->value << endl;\r\n        node = node->next;\r\n      }\r\n    }\r\n\r\n    string toString() {\r\n      return to_string(this->top);\r\n    }\r\n};\r\n\r\nint main() {\r\n  Stack stack;\r\n  stack.push(1);\r\n  stack.push(2);\r\n  stack.push(3);\r\n\r\n  cout << stack.peek() << endl; // 3\r\n\r\n  return 0;\r\n}\r\n```\r\n</details>\r\n\r\n### Resumen\r\n\r\nRetomando lo que hemos visto hasta ahora, podemos resumir las pilas de la siguiente manera:\r\n\r\n- Las pilas son estructuras de datos que siguen el principio de LIFO (Last In First Out), es decir, el ultimo elemento que entra es el primero que sale.\r\n- Las pilas son muy similares a las colas, pero en lugar de que el primer elemento que entra sea el primero en salir, el ultimo elemento que entra es el primero en salir.\r\n- Las pilas tienen dos operaciones principales: **push** y **pop**.\r\n- **push**: Agrega un elemento al tope de la pila.\r\n- **pop**: Elimina el elemento que esta en el tope de la pila.\r\n- **peek**: Devuelve el elemento que esta en el tope de la pila.\r\n- **isEmpty**: Devuelve true si la pila esta vacia, false en caso contrario.\r\n\r\n\r\n## Colas\r\n\r\n![Queue introduction](/media/stacks-and-queues-3.png)\r\n\r\nLas colas son estructuras de datos que siguen el principio de FIFO (First In First Out), es decir, el primer elemento que entra es el primero que sale. Las colas son muy similares a las pilas, pero en lugar de que el ultimo elemento que entra sea el primero en salir, el primer elemento que entra es el primero en salir.\r\n\r\n![Queue example](/media/stacks-and-queues-4.png)\r\n\r\n### Operaciones\r\n\r\n- **Enqueue**: Agrega un elemento al final de la cola.\r\n- **Dequeue**: Elimina el primer elemento de la cola.\r\n- **Peek**: Devuelve el primer elemento de la cola.\r\n- **isEmpty**: Devuelve true si la cola esta vacia, false en caso contrario.\r\n\r\n### Implementacion de pilas en diferentes lenguajes de programación\r\n\r\n<details>\r\n  <summary>Python</summary>\r\n\r\n```python\r\nclass QueueNode:\r\n    def __init__(self, value):\r\n        self.value = value\r\n        self.next = None\r\n\r\nclass Queue:\r\n    def __init__(self):\r\n        self.first = None\r\n        self.last = None\r\n\r\n    def enqueue(self, value):\r\n        node = QueueNode(value)\r\n        if self.last is not None:\r\n            self.last.next = node\r\n        self.last = node\r\n        if self.first is None:\r\n            self.first = self.last\r\n\r\n    def dequeue(self):\r\n        if self.first is None:\r\n            return None\r\n        node = self.first\r\n        self.first = self.first.next\r\n        if self.first is None:\r\n            self.last = None\r\n        return node.value\r\n\r\n    def peek(self):\r\n        if self.first is None:\r\n            return None\r\n        return self.first.value\r\n\r\n    def is_empty(self):\r\n        return self.first is None\r\n\r\n    def print(self):\r\n        node = self.first\r\n        while node is not None:\r\n            print(node.value)\r\n            node = node.next\r\n\r\n    def __str__(self):\r\n        return str(self.first)\r\n\r\nqueue = Queue()\r\nqueue.enqueue(1)\r\nqueue.enqueue(2)\r\nqueue.enqueue(3)\r\n\r\nprint(queue.peek()) # 1\r\n```\r\n</details>\r\n\r\n<details>\r\n  <summary>JavaScript</summary>\r\n\r\n```javascript\r\nclass QueueNode {\r\n  constructor(value) {\r\n    this.value = value;\r\n    this.next = null;\r\n  }\r\n}\r\n\r\nclass Queue {\r\n  constructor() {\r\n    this.first = null;\r\n    this.last = null;\r\n  }\r\n\r\n  enqueue(value) {\r\n    const node = new QueueNode(value);\r\n    if (this.last !== null) {\r\n      this.last.next = node;\r\n    }\r\n    this.last = node;\r\n    if (this.first === null) {\r\n      this.first = this.last;\r\n    }\r\n  }\r\n\r\n  dequeue() {\r\n    if (this.first === null) {\r\n      return null;\r\n    }\r\n    const node = this.first;\r\n    this.first = this.first.next;\r\n    if (this.first === null) {\r\n      this.last = null;\r\n    }\r\n    return node.value;\r\n  }\r\n\r\n  peek() {\r\n    if (this.first === null) {\r\n      return null;\r\n    }\r\n    return this.first.value;\r\n  }\r\n\r\n  isEmpty() {\r\n    return this.first === null;\r\n  }\r\n\r\n  print() {\r\n    let node = this.first;\r\n    while (node !== null) {\r\n      console.log(node.value);\r\n      node = node.next;\r\n    }\r\n  }\r\n\r\n  toString() {\r\n    return this.first;\r\n  }\r\n}\r\n\r\nconst queue = new Queue();\r\nqueue.enqueue(1);\r\nqueue.enqueue(2);\r\nqueue.enqueue(3);\r\n\r\nconsole.log(queue.peek()); // 1\r\n```\r\n</details>\r\n\r\n<details>\r\n  <summary>Java</summary>\r\n\r\n```java\r\nclass QueueNode {\r\n  int value;\r\n  QueueNode next;\r\n\r\n  QueueNode(int value) {\r\n    this.value = value;\r\n    this.next = null;\r\n  }\r\n}\r\n\r\nclass Queue {\r\n  QueueNode first;\r\n  QueueNode last;\r\n\r\n  Queue() {\r\n    this.first = null;\r\n    this.last = null;\r\n  }\r\n\r\n  void enqueue(int value) {\r\n    QueueNode node = new QueueNode(value);\r\n    if (this.last != null) {\r\n      this.last.next = node;\r\n    }\r\n    this.last = node;\r\n    if (this.first == null) {\r\n      this.first = this.last;\r\n    }\r\n  }\r\n\r\n  int dequeue() {\r\n    if (this.first == null) {\r\n      return -1;\r\n    }\r\n    QueueNode node = this.first;\r\n    this.first = this.first.next;\r\n    if (this.first == null) {\r\n      this.last = null;\r\n    }\r\n    return node.value;\r\n  }\r\n\r\n  int peek() {\r\n    if (this.first == null) {\r\n      return -1;\r\n    }\r\n    return this.first.value;\r\n  }\r\n\r\n  boolean isEmpty() {\r\n    return this.first == null;\r\n  }\r\n\r\n  void print() {\r\n    QueueNode node = this.first;\r\n    while (node != null) {\r\n      System.out.println(node.value);\r\n      node = node.next;\r\n    }\r\n  }\r\n\r\n  @Override\r\n  public String toString() {\r\n    return this.first.toString();\r\n  }\r\n}\r\n\r\npublic class Main {\r\n  public static void main(String[] args) {\r\n    Queue queue = new Queue();\r\n    queue.enqueue(1);\r\n    queue.enqueue(2);\r\n    queue.enqueue(3);\r\n\r\n    System.out.println(queue.peek()); // 1\r\n  }\r\n}\r\n```\r\n\r\n</details>\r\n\r\n<details>\r\n  <summary>C++</summary>\r\n\r\n```cpp\r\n#include <iostream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nstruct QueueNode {\r\n  int value;\r\n  QueueNode *next;\r\n\r\n  QueueNode(int value) {\r\n    this->value = value;\r\n    this->next = NULL;\r\n  }\r\n};\r\n\r\nclass Queue {\r\n  QueueNode *first;\r\n  QueueNode *last;\r\n\r\npublic:\r\n  Queue() {\r\n    this->first = NULL;\r\n    this->last = NULL;\r\n  }\r\n\r\n  void enqueue(int value) {\r\n    QueueNode *node = new QueueNode(value);\r\n    if (this->last != NULL) {\r\n      this->last->next = node;\r\n    }\r\n    this->last = node;\r\n    if (this->first == NULL) {\r\n      this->first = this->last;\r\n    }\r\n  }\r\n\r\n  int dequeue() {\r\n    if (this->first == NULL) {\r\n      return -1;\r\n    }\r\n    QueueNode *node = this->first;\r\n    this->first = this->first->next;\r\n    if (this->first == NULL) {\r\n      this->last = NULL;\r\n    }\r\n    return node->value;\r\n  }\r\n\r\n  int peek() {\r\n    if (this->first == NULL) {\r\n      return -1;\r\n    }\r\n    return this->first->value;\r\n  }\r\n\r\n  bool isEmpty() {\r\n    return this->first == NULL;\r\n  }\r\n\r\n  void print() {\r\n    QueueNode *node = this->first;\r\n    while (node != NULL) {\r\n      cout << node->value << endl;\r\n      node = node->next;\r\n    }\r\n  }\r\n\r\n  string toString() {\r\n    return to_string(this->first);\r\n  }\r\n};\r\n\r\nint main() {\r\n  Queue queue = Queue();\r\n  queue.enqueue(1);\r\n  queue.enqueue(2);\r\n  queue.enqueue(3);\r\n\r\n  cout << queue.peek() << endl; // 1\r\n}\r\n```\r\n</details>\r\n\r\n\r\n### Resumen\r\n\r\nPara finalizar, una cola es una estructura de datos que permite almacenar elementos en orden de llegada. Los elementos se pueden agregar y eliminar de la cola. La cola tiene dos operaciones básicas: `enqueue` y `dequeue`. El `enqueue` agrega un elemento al final de la cola. El `dequeue` elimina el elemento del frente de la cola. La cola tiene una operación adicional: `peek`. El `peek` devuelve el elemento del frente de la cola sin eliminarlo. La cola tiene una operación adicional: `isEmpty`. El `isEmpty` devuelve `true` si la cola está vacía y `false` si no lo está.\r\n";
						const data = {title:"Como funcionan las pilas y colas en la programación y como implementarlas en diferentes lenguajes de programación",tags:["pilas","colas","stacks","queues","data-structures","programming"]};
						const _internal = {
							type: 'content',
							filePath: "C:/Users/Carlo/dev/coatl.in/src/content/blog/stacks-and-queues.mdx",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
