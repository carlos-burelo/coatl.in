const id = "learning-js.mdx";
						const collection = "blog";
						const slug = "learning-js";
						const body = "\r\n## Introducci贸n\r\n\r\nPersonalmente creo que es de vital importancia entender algunos conceptos clave de javascript, como por ejemplo, el scope, la mutaci贸n, las funciones y los objetos, etc.\r\nya que estos nos proveen de diversas caracter铆sticas y funciones que nos permiten trabajar con el lenguaje de forma mas sencilla y eficiente, por eso me he dado a la tarea de agrupar algunas de estas caracter铆sticas de javascript que lo hacen el lenguaje popular que es hoy, y tratare de simplificar lo mas posible el tema para que pueda ser entendido por los dem谩s .\r\n\r\n## Caracter铆sticas del lenguaje\r\n\r\nComo cualquier otro lenguaje de programaci贸n, javascript esta dotado de diversas caracter铆sticas y peculiaridades que son las que definen con que facilidad podremos trabajar al momento de crear nuestras aplicaciones, siendo uno de los lenguajes mas populares actualmente veamos que nos puede ofrecer.\r\n\r\n### Scope \r\n\r\nEl **scope** en palabras sencillas lo podemos entender como un _ambiente_ o _entorno_ en el que se encuentra una variable, una funci贸n, una clase, etc.\r\n\r\nDentro de este entorno cualquier declaraci贸n de variable o funci贸n que se haga sera accesible solo dentro del mismo.\r\n\r\n```js\r\nconst name = 'John'\r\nconst age = 23\r\nconst country = 'US'\r\n// Todas las declaraciones anteriores se encuentran dentro del\r\n// scope \"global\" por lo que podemos acceder a ellas desde cualquier lugar.\r\n\r\nfunction getAge() {\r\n    return age // 23\r\n  }\r\n\r\nif (age > 18) {\r\n  const isOlder = true\r\n  // La constante \"isOlder\" solo esta disponible dentro del scope \"if\"\r\n  // por lo que no podemos acceder a ella desde fuera del scope, por ejemplo.\r\n}\r\n\r\nconsole.log(isOlder) // undefined\r\n  ```\r\n\r\n## Mutaci贸n 锔\r\n\r\nLa **mutaci贸n** es otro concepto que nos ayuda a entender el ciclo de vida de las variables en javascript, es decir, cuando una variable es mutada, esta puede cambiar de valor y esto puede causar un comportamiento inesperado si no sabemos en que punto de nuestra aplicaci贸n hemos mutado su valor, por ejemplo:\r\n\r\n```js\r\nconst fruits = ['apple', 'banana', 'orange']\r\nconst orange = fruits.pop() // [\"orange\"]\r\nconsole.log(fruits) // [\"apple\", \"banana\"]\r\n  ```\r\n\r\nComo podemos ver, al utilizar el m茅todo `.pop(){:js}` estamos obteniendo el ultimo valor de el arreglo `fruits{:js}`, pero a su vez este mismo ha perdido su ultimo valor, por lo que al momento de imprimir el valor de `fruits{:js}`, el elemento `\"orange\"{:.str}` ya no esta disponible.\r\n\r\nEn javascript tenemos m茅todos que mutan el valor de una variable, en este caso tomaremos de ejemplo los arreglos, como por ejemplo:\r\n\r\n- `.push(){:js}`: Agrega un elemento al final del arreglo\r\n- `.pop(){:js}`: Elimina el ultimo elemento del arreglo\r\n- `.shift(){:js}`: Elimina el primer elemento del arreglo\r\n- `.unshift(){:js}`: Agrega un elemento al inicio del arreglo\r\n\r\nM茅todos que mutan el valor de un string...\r\n\r\n- `.concat(){:js}`: Concatena un string con otro string\r\n- `.slice(){:js}`: Extrae una porci贸n del string\r\n- `.split(){:js}`: Divide un string en un arreglo\r\n- `.substr(){:js}`: Extrae una porci贸n del string\r\n- `.substring(){:js}`: Extrae una porci贸n del string\r\n- `.toLowerCase(){:js}`: Convierte el string a min煤sculas\r\n- `.toUpperCase(){:js}`: Convierte el string a may煤sculas\r\n\r\nM茅todos que mutan el valor de un numero...\r\n\r\n- `.toString(){:js}`: Convierte el numero en un string\r\n- `.toFixed(){:js}`: Convierte el numero en un string con una cantidad de decimales\r\n- `.toExponential(){:js}`: Convierte el numero en un string con una cantidad de decimales\r\n- `.toPrecision(){:js}`: Convierte el numero en un string con una cantidad de decimales\r\n\r\nY m茅todos que mutan el valor de un objeto.\r\n\r\n- `.assign(){:js}`: Asigna un valor a una propiedad de un objeto\r\n- `.deleteProperty(){:js}`: Elimina una propiedad de un objeto\r\n- `.defineProperty(){:js}`: Define una propiedad de un objeto\r\n- `.freeze(){:js}`: Congela un objeto\r\n- `.seal(){:js}`: Se cierra un objeto\r\n- `.preventExtensions(){:js}`: Evita que un objeto sea extensible\r\n- `.isFrozen(){:js}`: Verifica si un objeto esta congelado\r\n- `.isSealed(){:js}`: Verifica si un objeto esta cerrado\r\n- `.isExtensible(){:js}`: Verifica si un objeto es extensible\r\n\r\n## Funciones ○\r\n\r\nUna funci贸n la podemos entender como una serie de instrucciones agrupadas que puede ser invocada desde casi cualquier lugar, con la finalidad de separar en m贸dulos el c贸digo y poder reutilizarlo en diferentes partes de nuestra aplicaci贸n, la cual cuenta con una serie de caracter铆sticas que nos permiten realizar estas tareas.\r\n\r\nSi tenemos un bloque de c贸digo que realiza alguna operaci贸n, podemos crear una funci贸n que lo haga, y luego invocarla desde cualquier lugar sin tener que repetir el mismo c贸digo, por ejemplo:\r\n\r\n```javascript title = \"funciones.js\"\r\nfunction sumNumbers (num1, num2) {\r\n  return num1 + num2\r\n}\r\nsumNumbers(1, 2) // Retorna 3\r\n  ```\r\n\r\nAqu铆 tenemos el ejemplo mas com煤n de como crear una funci贸n en javascript, y como invocarla, pero debemos tener ciertos factores en cuenta a la hora de crear una funci贸n, por ejemplo:\r\n\r\n### `Nombre de la funci贸n`\r\n\r\nEl nombre debe ser claro, corto y consistente usando la nomenclatura **_camelCase_** en ingles, ademas de representar el prop贸sito de la funci贸n sin agregados extras.\r\nCom煤nmente de utilizan ciertos prefijos como `get` y `set` para indicar que la funci贸n es un _getter_ o _setter_ y sufijos como _Handler_ para indicar que la funci贸n es un gestor de eventos.\r\n\r\nPor ejemplo:\r\n\r\n- `sumNumbers{:.fn}`: Suma dos n煤meros\r\n- `getAge{:.fn}`: Retorna la edad de una persona\r\n- `setAge{:.fn}`: Cambia la edad de una persona\r\n- `onClickHandler{:.fn}`: Maneja el evento click\r\n\r\n### `Par谩metros`\r\n\r\nCuando creamos una funci贸n, podemos definir una serie de par谩metros que modificaran el comportamiento de la funci贸n en base al valor de estos.\r\n\r\nAl igual que con las funciones, los par谩metros deben ser consistes para identificar el valor que representa y su uso en el c贸digo, pero a diferencia de el nombre en las funciones, estos solo deben especificar el uso en su nombre sin agregados innecesarios.\r\n\r\n## Callbacks 锔\r\n\r\nLos **callbacks** son otras de esas funcionalidades que vale la pena conocer, si bien su uso se ha reducido significativamente en los 煤ltimos a帽os, este sigue presente en en lenguaje aunque de forma m谩s sutil en los m茅todos de un arreglo o en `polyfills{:.const}`.\r\n\r\nDe una manera muy sencilla, un callback no es m谩s que una funci贸n que se ejecutar谩 dentro de otra funci贸n una vez que la primera se termine de ejecutar, es decir, a una funci贸n le estaremos pasando otra una vez que la primera termin茅.\r\n\r\n```js\r\nconst numbers = [1, 2, 3, 4]\r\n\r\nconst doubles = numbers.map(number => number * 2)\r\n  // el callback es la funci贸n que recibe el map()\r\n  // en este caso es una funci贸n de tipo flecha\r\n  ```\r\n\r\nPor ejemplo, la funci贸n `map(){:js}` es un m茅todo del `Array.prototype{:js}`, es decir, un m茅todo disponible en todos los arreglos, este recibe un una funci贸n que le indique que hacer una vez que la funci贸n `.map(){:js}` ha terminado de ejecutarse y est谩 recibe un argumento que luego usa para hacer las transformaciones correspondientes.\r\n\r\n## Promesas \r\n\r\nLas Promesas las podemos considerar una evoluci贸n natural de los Callbacks, ya que un uso com煤n de los Callbacks se encuentran enfocados a operaciones _as铆ncronas_ ya que su sintaxis es m谩s comprensible que la de los callbacks, por ejemplo:\r\n\r\n```js\r\nconst res = fetch('https://url/api')\r\n  .then(res => res.json())\r\n  .catch(res => console.error(res))\r\n  .finally(() => console.log('Promise completely'))\r\n  ```\r\n\r\nUna promesa cuenta con 3 partes, el `.then(){:js}`, `.catch(){:js}`, y `.finally(){:js}` que son m茅todos que caracterizan a una promesa aunque por el momento solo hablaremos de then y catch que son los m谩s comunes.\r\n\r\n#### `.then(){:js}`\r\n\r\nPosiblemente este es el m茅todo principal por el cual se distinguen la promesas ya que es el que se encargar谩 de devolver o transformar un valor dependiendo de la implementaci贸n.\r\n\r\nMas f谩cilmente podemos entender a `then(){:js}` como el m茅todo que hace algo una vez que la promesa ha terminado, y dentro de then() escribimos un callback que es el que se encargar谩 de recibir la respuesta que la promesa haya devuelto.\r\n\r\n#### `.catch(){:js}`\r\n\r\nCatch podemos considerarlo como un m茅todo auxiliar, es decir, una contra-medida en caso de que la promesa no se resuelva correctamente y est谩 retorne un error, como por ejemplo, Si una petici贸n a una API devuelve un c贸digo de estado en el rango de 400 a 500, esto se considerar铆a como una promesa no resuelta, por lo que el m茅todo _.then()_ quedar铆a anulado y se saltar铆a directamente al m茅todo `catch(){:js}` y este recibir铆a un callback para manejar el error, por ejemplo:\r\n\r\n```js\r\nfetch('https://invalid.url')\r\n  .then(/*Esto ya no se ejecutara*/)\r\n  .catch(error => console.log(error))\r\n  // muestra el error en consola\r\n  ```\r\n\r\n## Async/Await \r\n\r\nY finalmente **async /await** es una forma de escribir una funci贸n que sea as铆ncrona con una sintaxis mas clara y limpia que las promesas en donde ahora contaremos con 2 palabras reservadas para realizar esto, que como pueden imaginar, son `async{:js}` y `await{:js}`.\r\n\r\n**Async** es la manera con la cual definimos que la que la funci贸n devolver谩 una promesa, si, una promesa. Aunque la funci贸n utiliza las palabra `async{:ts}`, esta es solo un indicador del tipo de funci贸n, en este caso, una funci贸n as铆ncrona, pero el tipo de dato que retorna es una promesa (_Promise_).\r\n\r\n**Await** es la instrucci贸n que indica que la funci贸n esperara a que la promesa se resuelva, antes de continuar con las siguientes instrucciones.\r\n\r\n```js\r\nasync function getData () {\r\n  const res = await fetch('https://url/api')\r\n  const data = await res.json()\r\n  return data\r\n}\r\n```\r\n\r\nTanto `fetch(){:js}` como su m茅todo `.json(){:js}` son funciones as铆ncronas, es decir, que toman un determinado tiempo antes de devolver un valor, por lo que definimos la palabra **await** para indicarle que nos esperaremos a que la promesa nos devuelva el valor que esperamos para poder continuar con las operaciones, en este caso como ambas funciones son as铆ncronas, definimos 2 veces las palabras await para tener una continuidad correcta en el procesamiento de los datos.\r\n\r\n## Notas finales\r\n\r\nQuisiera hacer menci贸n que algunas de las cosas que mencion茅 como algunas reglas de escritura de c贸digo, son opiniones personales y no deber铆an tomarse como norma absoluta para el lenguaje, pero si debo mencionar que muchas de estas reglas se usan actualmente ya que permite una mejor colaboraci贸n en las aplicaciones que realices.";
						const data = {title:"Conceptos b谩sicos de javascript para principiantes y no tan principiantes",tags:["javascript","conceptos","b谩sicos","principiantes","funciones","objetos","scope","mutaci贸n","callbacks","promesas","async/await"]};
						const _internal = {
							type: 'content',
							filePath: "C:/Users/Carlo/dev/coatl.in/src/content/blog/learning-js.mdx",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
