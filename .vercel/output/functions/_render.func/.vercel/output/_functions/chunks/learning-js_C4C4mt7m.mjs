const id = "learning-js.mdx";
						const collection = "blog";
						const slug = "learning-js";
						const body = "\r\n## Introducción\r\n\r\nPersonalmente creo que es de vital importancia entender algunos conceptos clave de javascript, como por ejemplo, el scope, la mutación, las funciones y los objetos, etc.\r\nya que estos nos proveen de diversas características y funciones que nos permiten trabajar con el lenguaje de forma mas sencilla y eficiente, por eso me he dado a la tarea de agrupar algunas de estas características de javascript que lo hacen el lenguaje popular que es hoy, y tratare de simplificar lo mas posible el tema para que pueda ser entendido por los demás 😀.\r\n\r\n## Características del lenguaje\r\n\r\nComo cualquier otro lenguaje de programación, javascript esta dotado de diversas características y peculiaridades que son las que definen con que facilidad podremos trabajar al momento de crear nuestras aplicaciones, siendo uno de los lenguajes mas populares actualmente veamos que nos puede ofrecer.\r\n\r\n### Scope 🟦\r\n\r\nEl **scope** en palabras sencillas lo podemos entender como un _ambiente_ o _entorno_ en el que se encuentra una variable, una función, una clase, etc.\r\n\r\nDentro de este entorno cualquier declaración de variable o función que se haga sera accesible solo dentro del mismo.\r\n\r\n```js\r\nconst name = 'John'\r\nconst age = 23\r\nconst country = 'US'\r\n// Todas las declaraciones anteriores se encuentran dentro del\r\n// scope \"global\" por lo que podemos acceder a ellas desde cualquier lugar.\r\n\r\nfunction getAge() {\r\n    return age // 23\r\n  }\r\n\r\nif (age > 18) {\r\n  const isOlder = true\r\n  // La constante \"isOlder\" solo esta disponible dentro del scope \"if\"\r\n  // por lo que no podemos acceder a ella desde fuera del scope, por ejemplo.\r\n}\r\n\r\nconsole.log(isOlder) // undefined\r\n  ```\r\n\r\n## Mutación ☢️\r\n\r\nLa **mutación** es otro concepto que nos ayuda a entender el ciclo de vida de las variables en javascript, es decir, cuando una variable es mutada, esta puede cambiar de valor y esto puede causar un comportamiento inesperado si no sabemos en que punto de nuestra aplicación hemos mutado su valor, por ejemplo:\r\n\r\n```js\r\nconst fruits = ['apple', 'banana', 'orange']\r\nconst orange = fruits.pop() // [\"orange\"]\r\nconsole.log(fruits) // [\"apple\", \"banana\"]\r\n  ```\r\n\r\nComo podemos ver, al utilizar el método `.pop(){:js}` estamos obteniendo el ultimo valor de el arreglo `fruits{:js}`, pero a su vez este mismo ha perdido su ultimo valor, por lo que al momento de imprimir el valor de `fruits{:js}`, el elemento `\"orange\"{:.str}` ya no esta disponible.\r\n\r\nEn javascript tenemos métodos que mutan el valor de una variable, en este caso tomaremos de ejemplo los arreglos, como por ejemplo:\r\n\r\n- `.push(){:js}`: Agrega un elemento al final del arreglo\r\n- `.pop(){:js}`: Elimina el ultimo elemento del arreglo\r\n- `.shift(){:js}`: Elimina el primer elemento del arreglo\r\n- `.unshift(){:js}`: Agrega un elemento al inicio del arreglo\r\n\r\nMétodos que mutan el valor de un string...\r\n\r\n- `.concat(){:js}`: Concatena un string con otro string\r\n- `.slice(){:js}`: Extrae una porción del string\r\n- `.split(){:js}`: Divide un string en un arreglo\r\n- `.substr(){:js}`: Extrae una porción del string\r\n- `.substring(){:js}`: Extrae una porción del string\r\n- `.toLowerCase(){:js}`: Convierte el string a minúsculas\r\n- `.toUpperCase(){:js}`: Convierte el string a mayúsculas\r\n\r\nMétodos que mutan el valor de un numero...\r\n\r\n- `.toString(){:js}`: Convierte el numero en un string\r\n- `.toFixed(){:js}`: Convierte el numero en un string con una cantidad de decimales\r\n- `.toExponential(){:js}`: Convierte el numero en un string con una cantidad de decimales\r\n- `.toPrecision(){:js}`: Convierte el numero en un string con una cantidad de decimales\r\n\r\nY métodos que mutan el valor de un objeto.\r\n\r\n- `.assign(){:js}`: Asigna un valor a una propiedad de un objeto\r\n- `.deleteProperty(){:js}`: Elimina una propiedad de un objeto\r\n- `.defineProperty(){:js}`: Define una propiedad de un objeto\r\n- `.freeze(){:js}`: Congela un objeto\r\n- `.seal(){:js}`: Se cierra un objeto\r\n- `.preventExtensions(){:js}`: Evita que un objeto sea extensible\r\n- `.isFrozen(){:js}`: Verifica si un objeto esta congelado\r\n- `.isSealed(){:js}`: Verifica si un objeto esta cerrado\r\n- `.isExtensible(){:js}`: Verifica si un objeto es extensible\r\n\r\n## Funciones 🐛➡🦋\r\n\r\nUna función la podemos entender como una serie de instrucciones agrupadas que puede ser invocada desde casi cualquier lugar, con la finalidad de separar en módulos el código y poder reutilizarlo en diferentes partes de nuestra aplicación, la cual cuenta con una serie de características que nos permiten realizar estas tareas.\r\n\r\nSi tenemos un bloque de código que realiza alguna operación, podemos crear una función que lo haga, y luego invocarla desde cualquier lugar sin tener que repetir el mismo código, por ejemplo:\r\n\r\n```javascript title = \"funciones.js\"\r\nfunction sumNumbers (num1, num2) {\r\n  return num1 + num2\r\n}\r\nsumNumbers(1, 2) // Retorna 3\r\n  ```\r\n\r\nAquí tenemos el ejemplo mas común de como crear una función en javascript, y como invocarla, pero debemos tener ciertos factores en cuenta a la hora de crear una función, por ejemplo:\r\n\r\n### `Nombre de la función`\r\n\r\nEl nombre debe ser claro, corto y consistente usando la nomenclatura **_camelCase_** en ingles, ademas de representar el propósito de la función sin agregados extras.\r\nComúnmente de utilizan ciertos prefijos como `get` y `set` para indicar que la función es un _getter_ o _setter_ y sufijos como _Handler_ para indicar que la función es un gestor de eventos.\r\n\r\nPor ejemplo:\r\n\r\n- `sumNumbers{:.fn}`: Suma dos números\r\n- `getAge{:.fn}`: Retorna la edad de una persona\r\n- `setAge{:.fn}`: Cambia la edad de una persona\r\n- `onClickHandler{:.fn}`: Maneja el evento click\r\n\r\n### `Parámetros`\r\n\r\nCuando creamos una función, podemos definir una serie de parámetros que modificaran el comportamiento de la función en base al valor de estos.\r\n\r\nAl igual que con las funciones, los parámetros deben ser consistes para identificar el valor que representa y su uso en el código, pero a diferencia de el nombre en las funciones, estos solo deben especificar el uso en su nombre sin agregados innecesarios.\r\n\r\n## Callbacks ◀️\r\n\r\nLos **callbacks** son otras de esas funcionalidades que vale la pena conocer, si bien su uso se ha reducido significativamente en los últimos años, este sigue presente en en lenguaje aunque de forma más sutil en los métodos de un arreglo o en `polyfills{:.const}`.\r\n\r\nDe una manera muy sencilla, un callback no es más que una función que se ejecutará dentro de otra función una vez que la primera se termine de ejecutar, es decir, a una función le estaremos pasando otra una vez que la primera terminé.\r\n\r\n```js\r\nconst numbers = [1, 2, 3, 4]\r\n\r\nconst doubles = numbers.map(number => number * 2)\r\n  // el callback es la función que recibe el map()\r\n  // en este caso es una función de tipo flecha\r\n  ```\r\n\r\nPor ejemplo, la función `map(){:js}` es un método del `Array.prototype{:js}`, es decir, un método disponible en todos los arreglos, este recibe un una función que le indique que hacer una vez que la función `.map(){:js}` ha terminado de ejecutarse y está recibe un argumento que luego usa para hacer las transformaciones correspondientes.\r\n\r\n## Promesas 🤝\r\n\r\nLas Promesas las podemos considerar una evolución natural de los Callbacks, ya que un uso común de los Callbacks se encuentran enfocados a operaciones _asíncronas_ ya que su sintaxis es más comprensible que la de los callbacks, por ejemplo:\r\n\r\n```js\r\nconst res = fetch('https://url/api')\r\n  .then(res => res.json())\r\n  .catch(res => console.error(res))\r\n  .finally(() => console.log('Promise completely'))\r\n  ```\r\n\r\nUna promesa cuenta con 3 partes, el `.then(){:js}`, `.catch(){:js}`, y `.finally(){:js}` que son métodos que caracterizan a una promesa aunque por el momento solo hablaremos de then y catch que son los más comunes.\r\n\r\n#### `.then(){:js}`\r\n\r\nPosiblemente este es el método principal por el cual se distinguen la promesas ya que es el que se encargará de devolver o transformar un valor dependiendo de la implementación.\r\n\r\nMas fácilmente podemos entender a `then(){:js}` como el método que hace algo una vez que la promesa ha terminado, y dentro de then() escribimos un callback que es el que se encargará de recibir la respuesta que la promesa haya devuelto.\r\n\r\n#### `.catch(){:js}`\r\n\r\nCatch podemos considerarlo como un método auxiliar, es decir, una contra-medida en caso de que la promesa no se resuelva correctamente y está retorne un error, como por ejemplo, Si una petición a una API devuelve un código de estado en el rango de 400 a 500, esto se consideraría como una promesa no resuelta, por lo que el método _.then()_ quedaría anulado y se saltaría directamente al método `catch(){:js}` y este recibiría un callback para manejar el error, por ejemplo:\r\n\r\n```js\r\nfetch('https://invalid.url')\r\n  .then(/*Esto ya no se ejecutara*/)\r\n  .catch(error => console.log(error))\r\n  // muestra el error en consola\r\n  ```\r\n\r\n## Async/Await 🕒\r\n\r\nY finalmente **async /await** es una forma de escribir una función que sea asíncrona con una sintaxis mas clara y limpia que las promesas en donde ahora contaremos con 2 palabras reservadas para realizar esto, que como pueden imaginar, son `async{:js}` y `await{:js}`.\r\n\r\n**Async** es la manera con la cual definimos que la que la función devolverá una promesa, si, una promesa. Aunque la función utiliza las palabra `async{:ts}`, esta es solo un indicador del tipo de función, en este caso, una función asíncrona, pero el tipo de dato que retorna es una promesa (_Promise_).\r\n\r\n**Await** es la instrucción que indica que la función esperara a que la promesa se resuelva, antes de continuar con las siguientes instrucciones.\r\n\r\n```js\r\nasync function getData () {\r\n  const res = await fetch('https://url/api')\r\n  const data = await res.json()\r\n  return data\r\n}\r\n```\r\n\r\nTanto `fetch(){:js}` como su método `.json(){:js}` son funciones asíncronas, es decir, que toman un determinado tiempo antes de devolver un valor, por lo que definimos la palabra **await** para indicarle que nos esperaremos a que la promesa nos devuelva el valor que esperamos para poder continuar con las operaciones, en este caso como ambas funciones son asíncronas, definimos 2 veces las palabras await para tener una continuidad correcta en el procesamiento de los datos.\r\n\r\n## Notas finales\r\n\r\nQuisiera hacer mención que algunas de las cosas que mencioné como algunas reglas de escritura de código, son opiniones personales y no deberían tomarse como norma absoluta para el lenguaje, pero si debo mencionar que muchas de estas reglas se usan actualmente ya que permite una mejor colaboración en las aplicaciones que realices.";
						const data = {title:"Conceptos básicos de javascript para principiantes y no tan principiantes",tags:["javascript","conceptos","básicos","principiantes","funciones","objetos","scope","mutación","callbacks","promesas","async/await"]};
						const _internal = {
							type: 'content',
							filePath: "C:/Users/Carlo/dev/coatl.in/src/content/blog/learning-js.mdx",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
